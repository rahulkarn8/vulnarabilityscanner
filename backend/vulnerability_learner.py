"""
Production-Grade Vulnerability Learning System
Safely learns new patterns without exposing the engine
to pattern poisoning or attacker-controlled regex injection.
"""

import re
import hashlib
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from sqlalchemy import and_
from datetime import datetime, timedelta
from auth import LearnedVulnerability


class VulnerabilityLearner:
    """Safe & controlled learning engine for new vulnerability patterns."""

    SCANNER_NAME = "learner"
    SCANNER_VERSION = "1.2.0"

    # Max length for a learned regex
    MAX_PATTERN_LEN = 200

    # Automatically expire learned patterns after 120 days
    PATTERN_TTL_DAYS = 120

    # Prevent overly broad or dangerous patterns
    FORBIDDEN_REGEX = [
        r"\.\*",           # catches everything
        r"\(.+\)\1",       # catastrophic backtracking pattern
        r"\(\?P<.*?>",     # named capture groups allowed but not from untrusted input
        r"(?<=)",          # zero-length assertions
        r"[^\s]{40,}",     # extremely long tokens without spaces
    ]

    def __init__(self, db: Session):
        self.db = db
        self._has_expires_at_column = self._check_expires_at_column()
    
    def _check_expires_at_column(self) -> bool:
        """Check if expires_at column exists in the database"""
        try:
            from sqlalchemy import inspect, text
            inspector = inspect(self.db.bind)
            if inspector.has_table('learned_vulnerabilities'):
                columns = [col['name'] for col in inspector.get_columns('learned_vulnerabilities')]
                return 'expires_at' in columns
            return False
        except Exception:
            # Fallback: try to query with expires_at
            try:
                self.db.query(LearnedVulnerability).filter(
                    LearnedVulnerability.expires_at.isnot(None)
                ).limit(1).all()
                return True
            except Exception:
                return False

    # ------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------

    def learn_from_vulnerability(
        self,
        vulnerability: Dict[str, Any],
        language: str,
        code_snippet: str
    ) -> bool:
        """
        Safely attempt to learn a new vulnerability pattern.

        Returns False if:
        - pattern is unsafe
        - pattern already exists
        - pattern is too broad or too long
        """
        vuln_type = vulnerability.get("type", "")
        severity = vulnerability.get("severity", "medium")
        raw_match = vulnerability.get("match", "")

        if not vuln_type or not raw_match:
            return False

        pattern = self._extract_safe_pattern(raw_match)
        if not pattern:
            return False

        if not self._validate_pattern(pattern):
            return False

        # Check if already exists
        existing = self.db.query(LearnedVulnerability).filter(
            and_(
                LearnedVulnerability.pattern == pattern,
                LearnedVulnerability.language == language,
                LearnedVulnerability.is_active == 1
            )
        ).first()

        if existing:
            existing.discovered_count += 1
            existing.updated_at = datetime.utcnow()
            self.db.commit()
            return False

        # Sanitize snippet to avoid storing secrets
        sanitized_snippet = self._sanitize_snippet(code_snippet[:500])

        learned_data = {
            "name": vuln_type,
            "pattern": pattern,
            "language": language,
            "severity": severity,
            "description": f"Learned pattern for: {vuln_type}",
            "code_snippet": sanitized_snippet,
            "discovered_count": 1,
            "is_active": 1,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
        }
        
        # Only add expires_at if column exists
        if self._has_expires_at_column:
            learned_data["expires_at"] = datetime.utcnow() + timedelta(days=self.PATTERN_TTL_DAYS)
        
        learned = LearnedVulnerability(**learned_data)

        self.db.add(learned)
        self.db.commit()
        return True

    # ------------------------------------------------------------
    # Pattern Generation (SAFE)
    # ------------------------------------------------------------

    def _extract_safe_pattern(self, match: str) -> Optional[str]:
        """
        Convert an exact match into a safe, normalized regex.
        Ensures no attacker-controlled dynamic regex is created.
        """

        if len(match) > 120:
            # Too long, suspicious match
            return None

        # Escape everything first
        escaped = re.escape(match)

        # Convert string literals â†’ generic string pattern
        escaped = re.sub(r"'.+?'", r"'[^']+'", escaped)
        escaped = re.sub(r'".+?"', r'"[^"]+"', escaped)

        # Normalize numbers
        escaped = re.sub(r"\d+", r"\\d+", escaped)

        # Allow flexible whitespace
        escaped = escaped.replace(r"\ ", r"\s+")

        # Limit length
        if len(escaped) > self.MAX_PATTERN_LEN:
            return None

        return escaped

    # ------------------------------------------------------------
    # Pattern Validation & Safety Checks
    # ------------------------------------------------------------

    def _validate_pattern(self, pattern: str) -> bool:
        """Ensure pattern is not overly broad, malicious, or DoS-dangerous."""

        # Reject forbidden constructs
        for bad in self.FORBIDDEN_REGEX:
            try:
                if re.search(bad, pattern):
                    return False
            except re.error:
                # If the pattern itself causes a regex error when checking,
                # it's likely invalid - but we'll let the compile check catch it
                # Just skip this forbidden check if it causes an error
                pass

        try:
            re.compile(pattern)
        except Exception:
            return False

        # Pattern must not match empty string
        try:
            if re.match(pattern, ""):
                return False
        except Exception:
            # If matching causes an error, the pattern is likely invalid
            return False

        return True

    # ------------------------------------------------------------
    # Snippet Sanitization
    # ------------------------------------------------------------

    def _sanitize_snippet(self, snippet: str) -> str:
        """
        Remove secrets before storing in DB.
        Avoid storing real tokens/passwords/API keys.
        """

        secret_patterns = [
            r"['\"]?(API_KEY|TOKEN|SECRET_KEY|PASSWORD)['\"]?\s*[:=]\s*['\"][^'\"]+['\"]",
            r"[A-Za-z0-9_\-]{24,}"  # high-entropy strings
        ]

        sanitized = snippet
        for sp in secret_patterns:
            sanitized = re.sub(sp, "<REDACTED>", sanitized)

        return sanitized

    # ------------------------------------------------------------
    # Retrieve Patterns
    # ------------------------------------------------------------

    def get_learned_patterns(self, language: str) -> List[Dict[str, Any]]:
        """Retrieve non-expired patterns."""

        now = datetime.utcnow()
        
        # Check if expires_at column exists by trying to query it
        try:
            # Try querying with expires_at filter
            patterns = self.db.query(LearnedVulnerability).filter(
                and_(
                    LearnedVulnerability.language == language,
                    LearnedVulnerability.is_active == 1,
                    LearnedVulnerability.expires_at > now
                )
            ).all()
        except Exception:
            # Column doesn't exist yet, query without expires_at filter
            # This handles the migration period gracefully
            patterns = self.db.query(LearnedVulnerability).filter(
                and_(
                    LearnedVulnerability.language == language,
                    LearnedVulnerability.is_active == 1
                )
            ).all()

        return [
            {
                "name": p.name,
                "pattern": p.pattern,
                "severity": p.severity,
                "description": p.description,
                "discovered_count": p.discovered_count,
                "expires_at": getattr(p, 'expires_at', None),  # Safe access in case column doesn't exist
            }
            for p in patterns
        ]

    # ------------------------------------------------------------
    # Manual Pattern Add
    # ------------------------------------------------------------

    def add_custom_pattern(self, name, pattern, language, severity, description):
        """Manually add safe custom pattern."""

        if not self._validate_pattern(pattern):
            raise ValueError("Pattern is unsafe or invalid")

        learned_data = {
            "name": name,
            "pattern": pattern,
            "language": language,
            "severity": severity,
            "description": description,
            "is_active": 1,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
        }
        
        # Only add expires_at if column exists
        if self._has_expires_at_column:
            learned_data["expires_at"] = datetime.utcnow() + timedelta(days=self.PATTERN_TTL_DAYS)
        
        learned = LearnedVulnerability(**learned_data)

        self.db.add(learned)
        self.db.commit()
        self.db.refresh(learned)
        return learned

    # ------------------------------------------------------------

    def update_pattern_usage(self, pattern_id: int):
        """Increment discovery count safely."""
        pattern = self.db.query(LearnedVulnerability).filter(
            LearnedVulnerability.id == pattern_id
        ).first()

        if pattern:
            pattern.discovered_count += 1
            pattern.updated_at = datetime.utcnow()
            self.db.commit()
