import subprocess
import json
import os
import tempfile
from typing import List, Dict, Any, Optional
from pathlib import Path
import hashlib


class VulnerabilityScanner:
    """Integrates with external vulnerability scanning tools (Bandit + cppcheck)"""

    def __init__(self) -> None:
        self.bandit_path = self._find_command("bandit")
        self.cppcheck_path = self._find_command("cppcheck")
        self.bandit_version = self._get_tool_version(self.bandit_path, ["--version"])
        self.cppcheck_version = self._get_tool_version(self.cppcheck_path, ["--version"])

    # ---------------------------------------------------------
    # Tool discovery & version
    # ---------------------------------------------------------

    def _find_command(self, command: str) -> Optional[str]:
        """Find if a command is available in PATH."""
        try:
            cmd = ["where", command] if os.name == "nt" else ["which", command]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
            )
            if result.returncode == 0:
                return result.stdout.strip().splitlines()[0]
        except Exception:
            pass
        return None

    def _get_tool_version(self, path: Optional[str], version_args: List[str]) -> Optional[str]:
        """Best-effort tool version detection."""
        if not path:
            return None
        try:
            result = subprocess.run(
                [path] + version_args,
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0 and result.stdout:
                # Take first line
                return result.stdout.strip().splitlines()[0]
        except Exception:
            return None
        return None

    # ---------------------------------------------------------
    # Python (Bandit)
    # ---------------------------------------------------------

    def scan_python_file(self, file_path: str) -> List[Dict[str, Any]]:
        """
        Scan Python file using Bandit.

        Returns a list of normalized vulnerability dicts with:
        - type, rule_id, cwe_id, severity, confidence, description
        - file_path, line_number, code_snippet
        - scanner, scanner_version
        """
        vulnerabilities: List[Dict[str, Any]] = []

        if not os.path.isfile(file_path):
            print(f"Warning: Python file not found: {file_path}")
            return vulnerabilities

        if not self.bandit_path:
            print("Warning: Bandit not found. Install with: pip install bandit")
            return vulnerabilities

        try:
            result = subprocess.run(
                [
                    self.bandit_path,
                    "-f",
                    "json",
                    "-ll",  # show all severities
                    file_path,
                ],
                capture_output=True,
                text=True,
                timeout=60,
            )

            stdout = result.stdout.strip()
            if not stdout:
                return vulnerabilities

            try:
                bandit_output = json.loads(stdout)
            except json.JSONDecodeError:
                print(f"Warning: Could not parse Bandit output for {file_path}")
                return vulnerabilities

            for issue in bandit_output.get("results", []):
                rule_id = issue.get("test_id") or issue.get("test_name") or "BANDIT"
                cwe_id = None
                issue_cwe = issue.get("issue_cwe")
                if isinstance(issue_cwe, dict):
                    cwe_id = issue_cwe.get("id")

                sev = self._map_bandit_severity(issue.get("issue_severity", "UNKNOWN"))
                conf = issue.get("issue_confidence", "UNKNOWN")

                line = issue.get("line_number", 0)
                snippet = self._get_code_snippet(file_path, line)

                vulnerabilities.append(
                    {
                        "type": issue.get("test_name", "Unknown"),
                        "rule_id": rule_id,
                        "cwe_id": cwe_id,
                        "severity": sev,
                        "confidence": conf,
                        "description": issue.get("issue_text", ""),
                        "file_path": file_path,
                        "line_number": line,
                        "code_snippet": snippet,
                        "scanner": "bandit",
                        "scanner_version": self.bandit_version,
                    }
                )

        except subprocess.TimeoutExpired:
            print(f"Warning: Bandit scan timed out for {file_path}")
        except Exception as e:
            print(f"Error running Bandit on {file_path}: {e}")

        return self._dedupe(vulnerabilities)

    # ---------------------------------------------------------
    # C++ (cppcheck)
    # ---------------------------------------------------------

    def scan_cpp_file(self, file_path: str) -> List[Dict[str, Any]]:
        """
        Scan C/C++ file using cppcheck.

        Returns normalized vulnerability dicts:
        - type, rule_id, severity, description, file_path, line_number, snippet
        - scanner, scanner_version
        """
        vulnerabilities: List[Dict[str, Any]] = []

        if not os.path.isfile(file_path):
            print(f"Warning: C/C++ file not found: {file_path}")
            return vulnerabilities

        if not self.cppcheck_path:
            print(
                "Warning: cppcheck not found. Install with: apt-get install cppcheck or brew install cppcheck"
            )
            return vulnerabilities

        json_output_path = None
        try:
            # Create temporary file for JSON output
            with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as tmp_file:
                json_output_path = tmp_file.name

            try:
                result = subprocess.run(
                    [
                        self.cppcheck_path,
                        "--enable=all",
                        "--suppress=missingIncludeSystem",
                        "--template=json",
                        "--json",
                        f"--json-output-file={json_output_path}",
                        file_path,
                    ],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )

                if not os.path.exists(json_output_path):
                    return vulnerabilities

                with open(json_output_path, "r", encoding="utf-8", errors="ignore") as f:
                    try:
                        cpp_data = json.load(f)
                    except json.JSONDecodeError:
                        print(f"Warning: Could not parse cppcheck JSON for {file_path}")
                        return vulnerabilities

                errors = self._extract_cppcheck_errors(cpp_data)

                for error in errors:
                    rule_id = error.get("id", "CPPCHECK")
                    severity = self._map_cppcheck_severity(error.get("severity", "information"))
                    descr = error.get("message") or error.get("msg") or ""

                    # Locations may be a list
                    locations = error.get("locations") or error.get("location") or []
                    if isinstance(locations, dict):
                        locations = [locations]

                    line = 0
                    for loc in locations:
                        if loc.get("file") == file_path:
                            line = loc.get("line", 0)
                            break
                    if line == 0:
                        line = error.get("line", 0)

                    snippet = self._get_code_snippet(file_path, line)

                    vulnerabilities.append(
                        {
                            "type": error.get("id", "Unknown"),
                            "rule_id": rule_id,
                            "cwe_id": None,  # cppcheck generally does not provide CWE by default
                            "severity": severity,
                            "description": descr,
                            "file_path": file_path,
                            "line_number": line,
                            "code_snippet": snippet,
                            "scanner": "cppcheck",
                            "scanner_version": self.cppcheck_version,
                        }
                    )
            finally:
                if json_output_path and os.path.exists(json_output_path):
                    os.unlink(json_output_path)

        except subprocess.TimeoutExpired:
            print(f"Warning: cppcheck scan timed out for {file_path}")
        except Exception as e:
            print(f"Error running cppcheck on {file_path}: {e}")

        return self._dedupe(vulnerabilities)

    def _extract_cppcheck_errors(self, cpp_data: Any) -> List[Dict[str, Any]]:
        """Handle different cppcheck JSON structures robustly."""
        errors: List[Dict[str, Any]] = []

        if isinstance(cpp_data, dict):
            # Common format: {"errors": [ { "id": ..., ... } ]}
            if "errors" in cpp_data and isinstance(cpp_data["errors"], list):
                for item in cpp_data["errors"]:
                    # sometimes nested under "error" or "message"
                    if isinstance(item, dict):
                        if "error" in item and isinstance(item["error"], dict):
                            errors.append(item["error"])
                        elif "message" in item and isinstance(item["message"], dict):
                            errors.append(item["message"])
                        else:
                            errors.append(item)
        elif isinstance(cpp_data, list):
            # Less common: list of items
            for item in cpp_data:
                if isinstance(item, dict):
                    if "error" in item and isinstance(item["error"], dict):
                        errors.append(item["error"])
                    else:
                        errors.append(item)

        return errors

    # ---------------------------------------------------------
    # Severity mapping
    # ---------------------------------------------------------

    def _map_bandit_severity(self, severity: str) -> str:
        mapping = {
            "LOW": "low",
            "MEDIUM": "medium",
            "HIGH": "high",
            "CRITICAL": "critical",
        }
        return mapping.get(severity.upper(), "medium")

    def _map_cppcheck_severity(self, severity: str) -> str:
        mapping = {
            "error": "high",
            "warning": "medium",
            "style": "low",
            "performance": "low",
            "portability": "low",
            "information": "low",
        }
        return mapping.get(severity.lower(), "medium")

    # ---------------------------------------------------------
    # Snippet & dedupe
    # ---------------------------------------------------------

    def _get_code_snippet(self, file_path: str, line_number: int, context_lines: int = 3) -> str:
        """Get code snippet around a line number."""
        if line_number <= 0:
            line_number = 1
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()

            start_line = max(0, line_number - context_lines - 1)
            end_line = min(len(lines), line_number + context_lines)

            snippet_lines = lines[start_line:end_line]
            return "".join(snippet_lines)
        except Exception:
            return ""

    def _dedupe(self, vulns: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Deduplicate findings using (rule_id, file_path, line_number, match-hash)."""
        seen = set()
        deduped: List[Dict[str, Any]] = []

        for v in vulns:
            key_parts = [
                v.get("rule_id") or v.get("type") or "",
                v.get("file_path") or "",
                str(v.get("line_number") or 0),
            ]
            # Add hash of description to make it stable
            desc = (v.get("description") or "").encode("utf-8", errors="ignore")
            desc_hash = hashlib.md5(desc).hexdigest()
            key_parts.append(desc_hash)

            key = "|".join(key_parts)

            if key not in seen:
                seen.add(key)
                deduped.append(v)

        return deduped
