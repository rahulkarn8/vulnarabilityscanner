import ast
import re
import hashlib
from dataclasses import dataclass
from typing import List, Dict, Any, Optional, Literal, Set

from sqlalchemy.orm import Session

from code_analyzer import CodeStructure


Severity = Literal["critical", "high", "medium", "low", "info"]


@dataclass
class VulnerabilityFinding:
    type: str
    rule_id: str
    cwe_id: Optional[str]
    severity: Severity
    description: str
    line_number: int
    code_snippet: str
    match: Optional[str]
    scanner: str
    scanner_version: str
    language: str
    file_path: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "type": self.type,
            "rule_id": self.rule_id,
            "cwe_id": self.cwe_id,
            "severity": self.severity,
            "description": self.description,
            "line_number": self.line_number,
            "code_snippet": self.code_snippet,
            "match": self.match,
            "scanner": self.scanner,
            "scanner_version": self.scanner_version,
            "language": self.language,
            "file_path": self.file_path,
        }


class VulnerabilityDetector:
    """
    Production-grade SAST core detector for Python & C++.

    - Normalized output format with rule_id, cwe_id, severity
    - Regex + AST-based checks (Python)
    - Deduplication of overlapping findings
    - Supports learned patterns from DB (VulnerabilityLearner)
    - Precompiled regex patterns
    - Rule-level controls: disabled_rules, severity_overrides
    """

    SCANNER_NAME = "core_sast"
    SCANNER_VERSION = "2.0.0"

    def __init__(
        self,
        db: Optional[Session] = None,
        disabled_rules: Optional[List[str]] = None,
        severity_overrides: Optional[Dict[str, Severity]] = None,
    ) -> None:
        """
        Args:
            db: Optional SQLAlchemy Session for loading learned patterns.
            disabled_rules: Optional list of rule_ids to disable.
            severity_overrides: Optional mapping rule_id -> new severity.
        """
        self.db = db
        self.disabled_rules: Set[str] = set(disabled_rules or [])
        self.severity_overrides: Dict[str, Severity] = severity_overrides or {}

        # Raw pattern definitions (not compiled)
        self._python_raw_patterns = self._init_python_patterns()
        self._cpp_raw_patterns = self._init_cpp_patterns()

        # Load learned patterns first (so they also get compiled)
        # Skip for faster scans - learned patterns are optional
        if db is not None:
            try:
                self._load_learned_patterns()
            except Exception as e:
                # If loading learned patterns fails or is slow, just skip them
                # This prevents slow remote databases from blocking scans
                print(f"[INFO] Skipping learned patterns (non-critical): {e}")
                pass

        # Compile patterns
        self.python_patterns = self._compile_patterns(self._python_raw_patterns)
        self.cpp_patterns = self._compile_patterns(self._cpp_raw_patterns)

    # ---------------------------------------------------------------------
    # Learned patterns from DB
    # ---------------------------------------------------------------------
    def _load_learned_patterns(self) -> None:
        """
        Load learned patterns (from VulnerabilityLearner) and merge into
        base patterns. Learned patterns are expected to already contain
        name, pattern, severity, description fields.
        
        Optimized with timeout to prevent hanging on slow remote databases.
        """
        try:
            from vulnerability_learner import VulnerabilityLearner
            import signal

            learner = VulnerabilityLearner(self.db)

            # Add timeout for database queries to prevent hanging on slow remote DBs
            # Use a simple timeout wrapper
            def with_timeout(func, timeout_seconds=3):
                """Execute function with timeout"""
                import threading
                result = [None]
                exception = [None]
                
                def target():
                    try:
                        result[0] = func()
                    except Exception as e:
                        exception[0] = e
                
                thread = threading.Thread(target=target)
                thread.daemon = True
                thread.start()
                thread.join(timeout=timeout_seconds)
                
                if thread.is_alive():
                    print(f"[WARNING] Database query timed out after {timeout_seconds}s, skipping learned patterns")
                    return []
                
                if exception[0]:
                    raise exception[0]
                return result[0]
            
            # Load patterns with very short timeout (1 second) for remote databases
            # If database is slow, just skip learned patterns - they're optional
            try:
                learned_py = with_timeout(lambda: learner.get_learned_patterns("python"), timeout_seconds=1)
                learned_cpp = with_timeout(lambda: learner.get_learned_patterns("cpp"), timeout_seconds=1)
            except Exception as timeout_error:
                # Silently skip - learned patterns are optional for performance
                learned_py = []
                learned_cpp = []

            # Normalize learned patterns to include rule_id/cwe_id placeholders
            base_index = len(self._python_raw_patterns) + 1
            for i, p in enumerate(learned_py, start=base_index):
                rule = dict(p)
                rule.setdefault("name", f"Learned Python Pattern {i}")
                rule.setdefault("rule_id", f"PY-LRN-{i}")
                rule.setdefault("cwe_id", None)
                rule.setdefault("severity", "medium")
                self._python_raw_patterns.append(rule)

            base_index = len(self._cpp_raw_patterns) + 1
            for i, p in enumerate(learned_cpp, start=base_index):
                rule = dict(p)
                rule.setdefault("name", f"Learned C++ Pattern {i}")
                rule.setdefault("rule_id", f"CPP-LRN-{i}")
                rule.setdefault("cwe_id", None)
                rule.setdefault("severity", "medium")
                self._cpp_raw_patterns.append(rule)

        except Exception as e:
            # Non-fatal: engine should still work without DB
            print(f"[VulnerabilityDetector] Warning: could not load learned patterns: {e}")

    # ---------------------------------------------------------------------
    # Base Python patterns
    # ---------------------------------------------------------------------
    def _init_python_patterns(self) -> List[Dict[str, Any]]:
        """
        Core Python patterns. These are intentionally conservative to avoid
        too many false positives.
        """
        return [
            # -------------------------------
            # SQL Injection (string concat / interpolation)
            # -------------------------------
            {
                "name": "SQL Injection",
                "rule_id": "PY-001",
                "cwe_id": "CWE-89",
                # execute("... " + var) OR execute("... %s" % var) OR similar
                "pattern": r"\bexecute\s*\([^)]*(\+|%[^(])",
                "severity": "high",
                "description": "Potential SQL injection via string concatenation or interpolation in SQL query.",
            },

            # -------------------------------
            # Command Injection (os.system / shell=True)
            # -------------------------------
            {
                "name": "Command Injection",
                "rule_id": "PY-002",
                "cwe_id": "CWE-78",
                "pattern": r"os\.system\s*\(|subprocess\.(call|Popen|run)\s*\([^)]*shell\s*=\s*True",
                "severity": "critical",
                "description": "Potential command injection via os.system or subprocess with shell=True.",
            },

            # -------------------------------
            # Hardcoded Password
            # -------------------------------
            {
                "name": "Hardcoded Password",
                "rule_id": "PY-003",
                "cwe_id": "CWE-259",
                "pattern": r"(password|passwd|pwd)\s*=\s*['\"][^\"']+['\"]",
                "severity": "critical",
                "description": "Hardcoded password found in source code.",
            },

            # -------------------------------
            # Hardcoded API Keys / Tokens
            # -------------------------------
            {
                "name": "Hardcoded API Token",
                "rule_id": "PY-004",
                "cwe_id": "CWE-798",
                "pattern": r"(API_KEY|SECRET_KEY|TOKEN|ACCESS_KEY)\s*=\s*['\"][A-Za-z0-9_\-\.\=]{16,}['\"]",
                "severity": "high",
                "description": "Hardcoded API key or token detected.",
            },

            # -------------------------------
            # Weak Cryptography
            # -------------------------------
            {
                "name": "Weak Cryptography",
                "rule_id": "PY-005",
                "cwe_id": "CWE-328",
                "pattern": r"\bhashlib\.(md5|sha1)\b",
                "severity": "medium",
                "description": "Use of weak cryptographic hash function (MD5/SHA1).",
            },

            # -------------------------------
            # Insecure Random for security use
            # -------------------------------
            {
                "name": "Insecure Random",
                "rule_id": "PY-006",
                "cwe_id": "CWE-330",
                "pattern": r"\brandom\.(randint|random|randrange)\s*\(",
                "severity": "medium",
                "description": "Insecure PRNG used for security-sensitive operations.",
            },

            # -------------------------------
            # Eval
            # -------------------------------
            {
                "name": "Eval Usage",
                "rule_id": "PY-007",
                "cwe_id": "CWE-94",
                "pattern": r"\beval\s*\(",
                "severity": "high",
                "description": "Use of eval() can lead to arbitrary code execution.",
            },

            # -------------------------------
            # Unsafe Pickle Deserialization
            # -------------------------------
            {
                "name": "Pickle Deserialization",
                "rule_id": "PY-008",
                "cwe_id": "CWE-502",
                "pattern": r"\bpickle\.loads?\s*\(",
                "severity": "high",
                "description": "Unsafe pickle deserialization; untrusted data can lead to code execution.",
            },

            # -------------------------------
            # TLS verification disabled
            # -------------------------------
            {
                "name": "TLS Verification Disabled",
                "rule_id": "PY-009",
                "cwe_id": "CWE-295",
                "pattern": r"requests\.(get|post|put|delete|head|options)\s*\([^)]*verify\s*=\s*False",
                "severity": "medium",
                "description": "TLS certificate verification explicitly disabled (verify=False).",
            },

            # -------------------------------
            # Plain HTTP URLs (informational)
            # -------------------------------
            {
                "name": "Insecure HTTP URL",
                "rule_id": "PY-010",
                "cwe_id": "CWE-311",
                "pattern": r"['\"]http://[^\"']+['\"]",
                "severity": "low",
                "description": "Plain HTTP URL used instead of HTTPS.",
            },
        ]

    # ---------------------------------------------------------------------
    # Base C++ patterns
    # ---------------------------------------------------------------------
    def _init_cpp_patterns(self) -> List[Dict[str, Any]]:
        """
        Core C++ patterns. Intentionally focused and conservative.
        """
        return [
            # -------------------------------
            # Unsafe C string functions
            # -------------------------------
            {
                "name": "Unsafe C String Function",
                "rule_id": "CPP-001",
                "cwe_id": "CWE-120",
                "pattern": r"\b(strcpy|strcat|sprintf)\s*\(",
                "severity": "critical",
                "description": "Unsafe C string function (likely buffer overflow).",
            },

            # -------------------------------
            # Command Injection via system()
            # -------------------------------
            {
                "name": "Command Injection",
                "rule_id": "CPP-002",
                "cwe_id": "CWE-78",
                "pattern": r"\bsystem\s*\(",
                "severity": "high",
                "description": "Use of system() can lead to command injection.",
            },

            # -------------------------------
            # Manual memory free/new (generic warning)
            # -------------------------------
            {
                "name": "Manual Memory Management",
                "rule_id": "CPP-003",
                "cwe_id": "CWE-416",
                "pattern": r"\bdelete\s+|delete\[\]\s+|free\s*\(",
                "severity": "medium",
                "description": "Manual memory management detected (potential for use-after-free or leaks).",
            },

            # -------------------------------
            # Format string – variable as format
            # -------------------------------
            {
                "name": "Format String Vulnerability",
                "rule_id": "CPP-004",
                "cwe_id": "CWE-134",
                # printf(user_input) – no quotes around first argument
                "pattern": r"\bprintf\s*\(\s*[A-Za-z_]\w*\s*\)",
                "severity": "high",
                "description": "Potential format string vulnerability where user-controlled variable is used as format.",
            },
        ]

    # ---------------------------------------------------------------------
    # Pattern compilation helper
    # ---------------------------------------------------------------------
    def _compile_patterns(self, patterns: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        compiled: List[Dict[str, Any]] = []
        for p in patterns:
            rule = dict(p)
            rule_id = rule["rule_id"]

            # Apply severity override if provided
            if rule_id in self.severity_overrides:
                rule["severity"] = self.severity_overrides[rule_id]

            pattern_str = rule["pattern"]
            rule["compiled"] = re.compile(pattern_str, re.IGNORECASE | re.MULTILINE)
            compiled.append(rule)
        return compiled

    # ---------------------------------------------------------------------
    # Main detection entrypoint
    # ---------------------------------------------------------------------
    def detect(
        self,
        code: str,
        language: str,
        structure: Optional[CodeStructure] = None,
        file_path: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """
        Run static analysis on code and return a list of vulnerability dicts.

        Args:
            code: full source string
            language: 'python', 'cpp', or 'c++'
            structure: optional CodeStructure (from CodeAnalyzer) for future use
            file_path: optional file path for context

        Returns:
            List of normalized vulnerability dictionaries.
        """
        if not code:
            return []

        lang = language.lower().strip()
        if lang == "c++":
            lang = "cpp"

        if lang not in ("python", "cpp"):
            raise ValueError(f"Unsupported language for SAST detector: {language}")

        lines = code.split("\n")
        raw_findings: List[VulnerabilityFinding] = []

        # Regex-based rules
        patterns = self.python_patterns if lang == "python" else self.cpp_patterns
        for pat in patterns:
            rule_id = pat["rule_id"]
            if rule_id in self.disabled_rules:
                continue

            regex = pat["compiled"]
            for m in regex.finditer(code):
                line_number = code[: m.start()].count("\n") + 1
                snippet = self._snippet(lines, line_number)

                raw_findings.append(
                    VulnerabilityFinding(
                        type=pat["name"],
                        rule_id=rule_id,
                        cwe_id=pat.get("cwe_id"),
                        severity=pat["severity"],
                        description=pat["description"],
                        line_number=line_number,
                        code_snippet=snippet,
                        match=m.group(0),
                        scanner=self.SCANNER_NAME,
                        scanner_version=self.SCANNER_VERSION,
                        language=lang,
                        file_path=file_path,
                    )
                )

        # AST-based rules for Python
        if lang == "python":
            raw_findings.extend(self._ast_checks_python(code, lines, file_path))

        # Deduplicate
        deduped = self._dedupe(raw_findings)
        return [f.to_dict() for f in deduped]

    # ---------------------------------------------------------------------
    # AST-based checks (Python)
    # ---------------------------------------------------------------------
    def _ast_checks_python(
        self,
        code: str,
        lines: List[str],
        file_path: Optional[str],
    ) -> List[VulnerabilityFinding]:
        findings: List[VulnerabilityFinding] = []

        try:
            tree = ast.parse(code)
        except SyntaxError:
            # Code may be partial; skip AST-based checks
            return findings

        for node in ast.walk(tree):
            # --- Assert in production code ---
            if isinstance(node, ast.Assert):
                findings.append(
                    self._make_ast_vuln(
                        node=node,
                        lines=lines,
                        file_path=file_path,
                        name="Assert Used",
                        rule_id="PY-AST-001",
                        cwe_id="CWE-703",
                        desc="Assert should not be used for security or production logic.",
                        severity="low",
                    )
                )

            # --- exec() usage ---
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id == "exec":
                    findings.append(
                        self._make_ast_vuln(
                            node=node,
                            lines=lines,
                            file_path=file_path,
                            name="Exec Usage",
                            rule_id="PY-AST-002",
                            cwe_id="CWE-94",
                            desc="Use of exec() can lead to arbitrary code execution.",
                            severity="high",
                        )
                    )

            # --- AST-based SQLi heuristic: cursor.execute(f"...{user_input}...") or BinOp "+"
            if isinstance(node, ast.Call):
                func_name = self._get_call_name(node)
                if func_name.endswith(".execute") or func_name == "execute":
                    if node.args:
                        arg0 = node.args[0]
                        if isinstance(arg0, (ast.JoinedStr, ast.BinOp)):
                            findings.append(
                                self._make_ast_vuln(
                                    node=node,
                                    lines=lines,
                                    file_path=file_path,
                                    name="SQL Injection (AST)",
                                    rule_id="PY-AST-003",
                                    cwe_id="CWE-89",
                                    desc=(
                                        "SQL query built via string operations (f-string or concatenation). "
                                        "Use parameterized queries."
                                    ),
                                    severity="high",
                                )
                            )

        return findings

    def _make_ast_vuln(
        self,
        node: ast.AST,
        lines: List[str],
        file_path: Optional[str],
        name: str,
        rule_id: str,
        cwe_id: Optional[str],
        desc: str,
        severity: Severity,
    ) -> VulnerabilityFinding:
        line = getattr(node, "lineno", 1)
        return VulnerabilityFinding(
            type=name,
            rule_id=rule_id,
            cwe_id=cwe_id,
            severity=severity,
            description=desc,
            line_number=line,
            code_snippet=self._snippet(lines, line),
            match=None,
            scanner=self.SCANNER_NAME,
            scanner_version=self.SCANNER_VERSION,
            language="python",
            file_path=file_path,
        )

    def _get_call_name(self, node: ast.Call) -> str:
        """
        Return dotted name for a call: e.g., cursor.execute -> 'cursor.execute'.
        """
        if isinstance(node.func, ast.Name):
            return node.func.id
        if isinstance(node.func, ast.Attribute):
            parts = []
            cur = node.func
            while isinstance(cur, ast.Attribute):
                parts.append(cur.attr)
                cur = cur.value
            if isinstance(cur, ast.Name):
                parts.append(cur.id)
            parts.reverse()
            return ".".join(parts)
        return ""

    # ---------------------------------------------------------------------
    # Helper utilities
    # ---------------------------------------------------------------------
    def _snippet(self, lines: List[str], line: int, ctx: int = 3) -> str:
        start = max(0, line - ctx - 1)
        end = min(len(lines), line + ctx)
        return "\n".join(lines[start:end])

    def _dedupe(self, findings: List[VulnerabilityFinding]) -> List[VulnerabilityFinding]:
        """
        Deduplicate by (rule_id, line_number, match_hash) so overlaps
        from regex + AST don't blow up the report.
        """
        seen: set[str] = set()
        final: List[VulnerabilityFinding] = []

        for f in findings:
            match_text = f.match or f.code_snippet
            match_hash = hashlib.md5(match_text.encode("utf-8", errors="ignore")).hexdigest()
            key = f"{f.rule_id}:{f.line_number}:{match_hash}"
            if key not in seen:
                seen.add(key)
                final.append(f)

        return final
